# AUTOGENERATED! DO NOT EDIT! File to edit: 10_tools.ipynb (unless otherwise specified).

__all__ = ['LossesRecorderCallback', 'cat_views', 'repeat_labels', 'MultiViewsCallback', 'recorder_losses_avrg',
           'make_dir', 'set_kwrgs', 'save_model', 'save_CEL_SCL_losses', 'dict2str']

# Cell
from fastai.vision.all import *
import torch.nn as nn
from warnings import warn

# Cell
class LossesRecorderCallback(Callback):
    def __init__(self, *args, **kwrgs):
        super().__init__(*args, **kwrgs)
        self.usl_losses = [[], []]
        self.cel_losses = [[], []]

    def after_validate(self):
        self.cel_losses[1] += sum(self.loss_func.cel)/len(self.loss_func.cel)
        self.usl_losses[1] += sum(self.loss_func.usl)/len(self.loss_func.usl)
        self.loss_func.cel = []
        self.loss_func.usl = []

    def after_train(self):
        self.cel_losses[0] += sum(self.loss_func.cel)/len(self.loss_func.cel)
        self.usl_losses[0] += sum(self.loss_func.usl)/len(self.loss_func.usl)
        self.loss_func.cel = []
        self.loss_func.usl = []


# Cell
def cat_views(self):
    self.learn.xb = (torch.cat(self.xb),)

def repeat_labels(self):
    self.learn.yb = (self.y.repeat(self.nviews),)




# Cell

class MultiViewsCallback(Callback):
    '''Callback to concat different views before feeding the model and repeat labels after pred'''
    def __init__(self, nviews):
        super().__init__()
        self.nviews = nviews
    def after_pred(self): repeat_labels(self)
    def before_batch(self): cat_views(self)

# Cell
def recorder_losses_avrg(record, epochs):
    tr=torch.stack(record).cpu().detach().numpy()
    bs_per_epochs = tr.shape[0]//epochs
    if tr.shape[0] != bs_per_epochs*epochs:
        warn('Number of epochs could be wrong or spourios data')
        excess = tr.shape[0]%epochs
        tr = tr[:-excess]
    return tr.reshape(epochs,bs_per_epochs).mean(axis=1)

# Cell
def make_dir(fname):
    if not os.path.isdir(fname): os.mkdir(fname)

def set_kwrgs(loss_name, alpha, p, margin):
    kwrgs = {}
    if loss_name != 'CEL': kwrgs['p'] = p
    if loss_name in ['CEL-TL', 'CEL-SCL']: kwrgs['alpha'] = alpha
    if loss_name in ['TL', 'CEL-TL']: kwrgs['margin'] = margin
    return kwrgs

# def set_model(loss_name, dls, lin_ftrs):
#     print(loss_name)
#     ModelClass = nn.Sequential if loss_name in ['CEL', 'TL', 'SCL'] else MixedLossModel
#     head = create_head(512*2, lin_ftrs[0]) if loss_name in ['TL', 'SCL'] else create_head(512*2, dls.c, lin_ftrs=lin_ftrs)
#     encoder = create_body(resnet34, cut=-2)
#     model = ModelClass(encoder, head)
#     return model


def save_model(learn, loss_name, kwrgs):
    model_name = f'{loss_name}_{dict2str(kwrgs)}_.pt'
    make_dir(path_loss/'models')
    torch.save(learn.model, path_loss/'models'/model_name)

def save_CEL_SCL_losses(learn,logs_file):
    logs_df = pd.read_csv(logs_file)
    logs_df['train_CEL'] = learn.losses_recorder.cel_losses[0]
    logs_df['train_SCL'] = learn.losses_recorder.usl_losses[0]
    logs_df['val_SCL'] = learn.losses_recorder.usl_losses[1]
    logs_df['val_CEL'] = learn.losses_recorder.cel_losses[1]
    logs_df.to_csv(logs_file)

def dict2str(d):
    s = ''
    for k, v in d.items(): s += f' {k}={v}'
    return s
