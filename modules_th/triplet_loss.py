# AUTOGENERATED! DO NOT EDIT! File to edit: 01_triplet_loss.ipynb (unless otherwise specified).

__all__ = ['TripletLoss', 'MixedLoss', 'SumLoss', 'CEL', 'AnomalyDetectionModel', 'splitter', 'tl_accuracy', 'rm_embs',
           'UniformizedSplitter']

# Cell
from fastai.vision.all import *
import umap
import seaborn as sns; sns.set()
import numpy as np
import pandas as pd
import os
import torch.nn as nn
from sklearn.metrics import silhouette_score
from sklearn.cluster import AgglomerativeClustering
from sklearn.cluster import SpectralClustering

# Cell
class TripletLoss(Module):
    def __init__(self, p='cos', margin=0.1):
        self.margin = margin
        self.p = p

    def forward(self, embs, y):
        embs = embs.flatten(1)
        d = -embs@embs.T if self.p=='cos' else torch.cdist(embs,embs,self.p)
        N = len(embs)
        with torch.no_grad():
            # Getting indexes of the Positive and Negative sample of each Anchor
            dp, dn = d.clone(), d.clone()
            dp[y!=y[:,None]], dn[y==y[:,None]] = -np.inf, np.inf

            p = dp.argmax(1)
            n = dn.argmin(1)

        return (self.margin + d[range(N),p] - d[range(N),n]).clamp(0).sum()/N

class MixedLoss(Module):
    def __init__(self,  p='cos', alpha=1, margin=0.1):
        self.alpha = alpha
        self.CEL = CrossEntropyLossFlat()
        self.TL = TripletLoss(p='cos', margin=margin)

    def forward(self, out, y):
        CEL = self.CEL(out[0], y)
        TL = self.TL(out[1], y)
        return CEL + self.alpha*TL


class SumLoss(Module):
    def __init__(self, loss1 , loss2= CrossEntropyLossFlat, alpha=1.0, n_views=2, **kwargs):
        self.alpha = alpha
        self.loss1 = loss1(**kwargs)
        self.loss2 = loss2()
        self.n_views = n_views
        self.cel =[]
        self.usl = []
    def forward(self, out, y):
        y_cel = y.repeat(self.n_views)
        CEL = self.loss2(out[0],y_cel)
        self.cel.append(CEL)
        USL = self.loss1(out[1],y)
        self.usl.append(USL)
        return CEL+self.alpha*USL



class CEL(Module):
    def forward(self, out, y):
        CEL = CrossEntropyLossFlat()(out[0], y)
        return CEL



# Cell
class AnomalyDetectionModel(Module):
    def __init__(self, encoder, head):
        self.encoder, self.head = encoder, head

    def forward(self, x):
        embs = self.head[0:5](self.encoder(x))
        scrs = self.head[5:](embs)
        embs = F.normalize(embs)
        return scrs, embs

def splitter(model:(AnomalyDetectionModel,nn.Sequential)):
    if isinstance(model,AnomalyDetectionModel):
        return [params(model.encoder), params(model.head)]
    else:
        return [params(model[0]),params(model[1])]

def tl_accuracy(out, y):
    return accuracy(out[0], y)

def rm_embs(self):
    self.learn.pred = self.pred[0]

class UniformizedSplitter():
    def __init__(self,items,lbls,unif_fn,valid_pct=0.2, n_lbls=8, n_el=8):
        self.lbls = lbls
        self.unif_fn = unif_fn
        self.splits= RandomSplitter(valid_pct=valid_pct,seed=42)(items)
        self.n_lbls = n_lbls
        self.n_el = n_el
    def __call__(self,items):
        splits = self.splits
        return [self.unif_fn(idxs, self.lbls[idxs] , n_lbl=self.n_lbls, n_el=self.n_el) for idxs in splits]

