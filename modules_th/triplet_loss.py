# AUTOGENERATED! DO NOT EDIT! File to edit: 01_triplet_loss.ipynb (unless otherwise specified).

__all__ = ['TripletLoss', 'MixedLoss', 'TLModel', 'my_splitter', 'tl_accuracy']

# Cell
from fastai.vision.all import *
import umap
import seaborn as sns; sns.set()
import numpy as np
import pandas as pd
import os
import torch.nn as nn
from sklearn.metrics import silhouette_score
from sklearn.cluster import AgglomerativeClustering
from sklearn.cluster import SpectralClustering

# Cell
class TripletLoss(Module):
    def __init__(self, p='cos', margin=0.1):
        self.margin = margin
        self.p = p

    def forward(self, embs, y):
        embs = embs.flatten(1)
        d = -embs@embs.T if self.p=='cos' else torch.cdist(embs,embs,self.p)
        N = len(embs)
        with torch.no_grad():
            # Getting indexes of the Positive and Negative sample of each Anchor
            dp, dn = d.clone(), d.clone()
            dp[y!=y[:,None]], dn[y==y[:,None]] = -np.inf, np.inf

            p = dp.argmax(1)
            n = dn.argmin(1)

        return (self.margin + d[range(N),p] - d[range(N),n]).clamp(0).sum()/N

class MixedLoss(Module):
    def __init__(self, p='cos', alpha=1, margin=0.1):
        self.alpha = alpha
        self.CEL = CrossEntropyLossFlat()
        self.TL = TripletLoss(p='cos', margin=margin)

    def forward(self, out, y):
        CEL = self.CEL(out[0], y)
        TL = self.TL(out[1], y)
        return CEL + self.alpha*TL

# Cell
class TLModel(Module):
    def __init__(self, encoder, head):
        self.encoder, self.head = encoder, head

    def forward(self, x):
        embs = self.head[0:5](self.encoder(x))
        scrs = self.head[5:](embs)
        return scrs, embs

def my_splitter(model:TLModel):
    return [params(model.encoder), params(model.head)]

def tl_accuracy(out, y):
    return accuracy(out[0], y)